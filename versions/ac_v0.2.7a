#! /usr/bin/env python
import libtcodpy as libtcod
import math, textwrap, shelve, re, os, sys
################################
#         MAP BUILDING          #####################################################################################################
################################
class Tile:
    def __init__(self, blocked, block_sight = None):
        self.blocked = blocked
        self.explored = False # All lines start unexplored

        # By default, blocked tile blocks sight
        if block_sight is None: block_sight = blocked
        self.block_sight = block_sight
class Rect:
    def __init__(self, x, y, w, h):
        (self.x1, self.x2) = (x, x + w)
        (self.y1, self.y2) = (y, y + h)
    def center(self):
        center_x = (self.x1 + self.x2) / 2
        center_y = (self.y1 + self.y2) / 2
        return (center_x, center_y)
    def intersect(self, other):
        #returns true if this rectangle intersects with another one
        return (self.x1 <= other.x2 and self.x2 >= other.x1 and
                self.y1 <= other.y2 and self.y2 >= other.y1)
### DEFS ###
def create_room(room):
    global map
    #go through the tiles in the rectangle and make them passable    
    for x in range(room.x1 + 1, room.x2):
        for y in range(room.y1 + 1, room.y2):
            map[x][y].blocked = False
            map[x][y].block_sight = False
def create_h_tunnel(x1, x2, y): #min() and max() are used in case x1>x2
    global map
    for x in range(min(x1, x2), max(x1, x2) + 1):
        map[x][y].blocked = False
        map[x][y].block_sight = False
def create_v_tunnel(y1, y2, x): #min() and max() are used in case x1>x2
    global map
    for y in range(min(y1, y2), max(y1, y2) + 1):
        map[x][y].blocked = False
        map[x][y].block_sight = False
####################################################################################################
FONT = 'font/arial10x10.png'
(SCREEN_WIDTH, SCREEN_HEIGHT)  = (136, 76) # Total windows
(MAP_WIDTH, MAP_HEIGHT) = 116, 60 # Map Dimensions
(SIDEBAR_WIDTH, SIDEBAR_HEIGHT) = (20, MAP_HEIGHT) # Sidebar Dimensions
(PANEL_WIDTH, PANEL_HEIGHT) = (SCREEN_WIDTH, 16)# Low Panel Dimensions

# GUI Message Bar

# Level Screen
LEVEL_SCREEN_WIDTH = 40
CHARACTER_SCREEN_WIDTH = 30

# COLORS
color_dark_wall = libtcod.dark_grey
color_light_wall = libtcod.desaturated_orange
color_dark_ground = libtcod.grey
color_light_ground = libtcod.desaturated_yellow

COLOR_INFO = libtcod.white
COLOR_WARNING = libtcod.yellow
COLOR_ALARM = libtcod.red
COLOR_BOON = libtcod.green
COLOR_MAGIC = libtcod.cyan

# FOV
FOV_ALGO = 0  #default FOV algorithm
FOV_LIGHT_WALLS = True
TORCH_RADIUS = 10

INVENTORY_WIDTH = 50

HEAL_AMOUNT = 40
MANA_RECOVER = 10
HP_RECOVER = 10

LIGHTNING_DAMAGE = 40
LIGHTNING_RANGE = 5
CONFUSE_NUM_TURNS = 10
FIREBALL_RADIUS = 3
FIREBALL_DAMAGE = 25


################################
#        CLASSES / [CLASS]     #####################################################################################################
################################
class Object: #[object]
    def __init__(self, x, y, char, name, color, race=None, blocks=False, lootable='no',
                 always_visible=False, inventory=None, spellbook=None, fighter=None, ai=None, rune=False, item=None):
        self.x = x
        self.y = y
        self.char = char
        self.name = name
        self.color = color
        self.race = race
        self.lootable = lootable
        self.blocks = blocks
        self.always_visible = always_visible
        self.inventory = inventory
        self.spellbook = spellbook
        self.fighter = fighter
        self.ai = ai
        self.rune = rune
        self.item = item
        if self.ai: self.ai.owner = self
        if self.fighter: self.fighter.owner = self
        if self.item: self.item.owner = self
    def move(self, dx, dy):
        if not is_blocked(self.x + dx, self.y + dy):
            self.x += dx
            self.y += dy
    def random_move(self):
        x=0; dxy = (dnd_dice (-1, 1),dnd_dice (-1, 1))
        while is_blocked(self.x + dxy[0], self.y + dxy[1]) and x < 20:
            dxy = (dnd_dice (-1, 1),dnd_dice (-1, 1))
            x +=1
        self.move(dxy[0],dxy[1])
    def move_towards(self, target_x, target_y):
        (dx, dy) = (0, 0)
        #do a scan for quickest way to the target
        if distance((self.x+1, self.y+1),(target_x, target_y)) < distance((self.x+dx, self.y+dy),(target_x, target_y)): 
            if not is_blocked(self.x+1, self.y+1): (dx, dy) = (1, 1)
        if distance((self.x+1, self.y-1),(target_x, target_y)) < distance((self.x+dx, self.y+dy),(target_x, target_y)): 
            if not is_blocked(self.x+1, self.y-1): (dx, dy) = (1, -1)
        if distance((self.x-1, self.y+1),(target_x, target_y)) < distance((self.x+dx, self.y+dy),(target_x, target_y)): 
            if not is_blocked(self.x-1, self.y+1): (dx, dy) = (-1, 1)
        if distance((self.x-1, self.y-1),(target_x, target_y)) < distance((self.x+dx, self.y+dy),(target_x, target_y)): 
            if not is_blocked(self.x-1, self.y-1): (dx, dy) = (-1, -1)
        if distance((self.x+1, self.y+0),(target_x, target_y)) < distance((self.x+dx, self.y+dy),(target_x, target_y)): 
            if not is_blocked(self.x+1, self.y+0): (dx, dy) = (1, 0)
        if distance((self.x+0, self.y+1),(target_x, target_y)) < distance((self.x+dx, self.y+dy),(target_x, target_y)): 
            if not is_blocked(self.x+0, self.y+1): (dx, dy) = (0, 1)
        if distance((self.x+0, self.y-1),(target_x, target_y)) < distance((self.x+dx, self.y+dy),(target_x, target_y)): 
            if not is_blocked(self.x+0, self.y-1): (dx, dy) = (0, -1)
        if distance((self.x-1, self.y+0),(target_x, target_y)) < distance((self.x+dx, self.y+dy),(target_x, target_y)): 
            if not is_blocked(self.x-1, self.y+0): (dx, dy) = (-1, 0)
        self.move(dx, dy)
    def display_inventory(self, header):
        if len(self.inventory) == 0: message(self.name + 's inventory is empty')
        else: 
            options = [item.name for item in self.inventory]
            index = menu(header, options, INVENTORY_WIDTH, 'a')
            if index == None or len(self.inventory) == 0: return None
            return self.inventory[index].item
    def draw(self): 
        #only show if it's visible to the player; or it's set to "always visible" and on an explored tile
        if (libtcod.map_is_in_fov(fov_map, self.x, self.y) or
            (self.always_visible and map[self.x][self.y].explored)) or DEBUGMODE == 1:
            #set the color and then draw the character that represents this object at its position
            libtcod.console_set_foreground_color(con, self.color)
            libtcod.console_put_char(con, self.x, self.y, self.char, libtcod.BKGND_NONE)
    def clear(self):
        libtcod.console_put_char(con, self.x, self.y, ' ', libtcod.BKGND_NONE)
    def send_to_back(self): 
        # Makes object drawn first, so it get's overwritten when possible
        global objects
        objects.remove(self)
        objects.insert(0, self)
class Fighter: #[o.fighter]
    def __init__(self, hp, STR, DEX, CON, MAG, xp, mp=0, 
                 job=None, faction='monster', level=0, bab=0, death_function=None):
        # Setting all slots to 'empty'
        self.rhand = AC_empty
        self.lhand = AC_empty
        self.helm = AC_empty
        self.armor = AC_empty
        #rest self. are here
        self.hp = int(hp);self.max_hp = int(hp)
        self.STR = int(STR)
        self.DEX = int(DEX)
        self.CON = int(CON)
        self.MAG = int(MAG)
        self.xp = xp
        self.mp = mp;self.max_mp = mp
        self.job = job
        self.faction = faction
        self.level = level
        self.bab = bab
        self.death_function = death_function
    def attack(self, target):
        attack = melee_dice(self.owner, target, self.rhand.item) #Will return (1/0, damage), 1=hit, 0=miss
        if attack[0] == 0: message(self.owner.name.capitalize() + ' attacks '+ target.name +' but misses', libtcod.orange)
        elif attack[1] <= 0:message(self.owner.name.capitalize() + ' hits '+ target.name +' but did not cause any damage', libtcod.orange)
        else:
            message(self.owner.name.capitalize() + ' hits '+ target.name +'!', libtcod.orange)
            target.fighter.take_damage(attack[1])
    def take_damage(self, damage, attacker=None):
        if damage > 0:
            self.hp -= damage
            if self.hp <= 0:
                if self.death_function is not None: self.death_function(self.owner)
                if self.owner != player:
                    #if attacker == None: player.fighter.xp += (300 + 100*(self.level - player.fighter.level))/4
                    XP = (300 + 100*(self.level - player.fighter.level))/2
                    if XP <= 0: XP = 10
                    if attacker == None: player.fighter.xp += XP
                    else: attacker.fighter.xp += XP
    def heal(self, amount):
        self.hp += amount
        if self.hp > self.max_hp: self.hp = self.max_hp
    def heal_mp(self, amount):
        self.mp += amount
        if self.mp > self.max_mp: self.mp = self.max_mp
class BasicMonster():
    def __init__(self, state='normal', chasing_x=None, chasing_y=None):
        self.state = state
        (self.chasing_x, self.chasing_y) = (chasing_x, chasing_y)
    def take_turn(self):
        monster = self.owner
        target = closest_enemy(5, monster)
        if libtcod.map_is_in_fov(fov_map, monster.x, monster.y):
            if target == None: target = player
            (self.chasing_x, self.chasing_y) = (target.x, target.y) #remember where player last was seen
            self.state = 'chasing' #if player has been spotten he will find you
            if distance((monster.x, monster.y),(target.x, target.y)) >= 2: monster.move_towards(target.x, target.y)
            elif target.fighter.hp > 0: monster.fighter.attack(target)
        else: #if cannot see player
            if target != None: 
                (self.chasing_x, self.chasing_y) = (target.x, target.y) #remember where player last was seen
                self.state = 'chasing' #if player has been spotten he will find you
                if distance((monster.x, monster.y), (target.x, target.y)) >= 2: monster.move_towards(target.x, target.y)
                elif target.fighter.hp > 0: monster.fighter.attack(target)
            else:
                if self.state == 'chasing': #if has seen player, move towards last seen point
                    if monster.x == self.chasing_x and monster.y == self.chasing_y: self.state = 'normal'
                    else: monster.move_towards(self.chasing_x, self.chasing_y)
                else: monster.random_move()
class Item:
    def __init__(self, itemtype, weight, enchanted=0, equippable='no',
                 dmg=(0, 0, 0),
                 ac=0, max_dexmod=100,
                 use_function=None, consumable=(0,0)):
        # itemtype = all, helm, armor, weapon, potion
        # weight = none, light, medium, heavy
        # equippable = all, hand, hands, helm, armor, no
        self.itemtype = itemtype
        self.weight = weight
        self.enchanted = enchanted
        self.equippable = equippable
        self.dmg = dmg
        self.ac = ac
        self.max_dexmod = max_dexmod
        self.use_function = use_function
        self.consumable = consumable
    def equip(self, weapon_hand='none'): 
        if self.equippable == 'hand' and weapon_hand == 'right':
            if player.fighter.rhand.name == '':
                player.fighter.rhand = self.owner
                player.inventory.remove(self.owner)
                message('Now holding ' + self.owner.name + ' in the right hand')
            else: message('Your right hand is full!')
        elif self.equippable == 'hand' and weapon_hand == 'left':
            if player.fighter.lhand.name =='':
                player.fighter.lhand = self.owner
                player.inventory.remove(self.owner)
                message('Now holding ' + self.owner.name + ' in the left hand')
            else: message('Your left hand is full!')
        elif self.equippable == 'helm':
            if player.fighter.helm.name == '':        
                player.fighter.helm = self.owner
                player.inventory.remove(self.owner)
                message("You're now wearing " + self.owner.name)
            else: message("You're already wearing a helmet")
        elif self.equippable == 'armor':
            if player.fighter.armor.name == '':        
                player.fighter.armor = self.owner
                player.inventory.remove(self.owner)
                message("You're now wearing " + self.owner.name)
            else: message("You're already wearing an armor")
        else:
            message(self.owner.name + ' cannot be equipped')
    def use(self):
        if self.use_function == None: message ('The ' + self.owner.name + ' cannot be used')
        else: 
            use = item_use(self)
            if use == 'consume': self.consumable = (self.consumable[0], self.consumable[1]-1)
            message (self.owner.name.capitalize()+' has '+str(self.consumable[1])+' charges left', COLOR_WARNING)
    def pick_up(self, looted='no'):
        self.looted = looted
        if len(player.inventory) >= 26: message('Your inventory is full!')
        else:
            player.inventory.append(self.owner)
            if looted == 'no': objects.remove(self.owner)
            message ('Picked up ' + self.owner.name, libtcod.green)
    def drop(self):
        objects.append(self.owner)
        player.inventory.remove(self.owner)
        self.owner.x = player.x
        self.owner.y = player.y
        message('You drop ' + self.owner.name, COLOR_INFO)
################################
#      GAME ENGINE DEFS        #####################################################################################################
################################
def closest_enemy(max_range, owner=None):
    if owner == None: owner = player
    closest_enemy = None
    closest_dist = max_range + 1
    for object in objects:
        if object.fighter and not object == owner and libtcod.map_is_in_fov(fov_map, object.x, object.y) and is_enemy(owner, object):
            dist = distance((owner.x, owner.y), (object.x, object.y))
            if dist < closest_dist:
                closest_enemy = object
                closest_dist = dist
    return closest_enemy
def debug():
    global DEBUGMODE
    if len(sys.argv) > 1:    
        if 'd' in sys.argv[1]: 
            DEBUGMODE = 1
            print('DEBUGMODE set to 1')
        if 't' in sys.argv[1]:
            newgame_ok = new_game(True)
            if newgame_ok: play_game()
def distance(owner_xy, target_xy):
    return math.sqrt((target_xy[0] - owner_xy[0]) ** 2 + (target_xy[1] - owner_xy[1]) ** 2)
def dnd_dice(min, max):
    return libtcod.random_get_int(0, min, max)
def is_blocked(x, y):
    if map[x][y].blocked: return True
    for object in objects:
        if object.blocks and object.x == x and object.y == y:
            return True
    return False
def is_enemy(owner, target): # This is possibly obsolete?
    own_faction = owner.fighter.faction
    target_faction = target.fighter.faction
    if own_faction == 'player': return True
    elif own_faction == 'npc_hostile': return True
    elif own_faction == 'monster' and target_faction == 'monster': return False
    elif own_faction == 'monster' and target_faction != 'monster': return True
def melee_dice(attacker, defender, weapon):
    att_AB = melee_dice_ab(attacker, weapon)
    damage = melee_dice_dmg(attacker, weapon)
    def_AC = melee_dice_ac(defender)
    """ AB vs AC """
    if att_AB + dnd_dice(1,20) < def_AC: return (0, 0)
    else: return (1, damage)
def melee_dice_ab(object, weapon):
    STRmod = int((object.fighter.STR-10)/2)
    if int((object.fighter.DEX-10)/2) > object.fighter.armor.item.max_dexmod: DEXmod = int(object.fighter.armor.item.max_dexmod)
    else: DEXmod = int((object.fighter.DEX-10)/2)
    DEX_AB = DEXmod + object.fighter.bab + weapon.enchanted
    STR_AB = STRmod + object.fighter.bab + weapon.enchanted
    if weapon.weight == 'heavy': return STR_AB
    elif weapon.weight == 'light': return DEX_AB
    else:
        if DEX_AB > STR_AB: return DEX_AB
        elif STR_AB >= DEX_AB: return STR_AB
def melee_dice_ac(object):
    if int((object.fighter.DEX-10)/2) > object.fighter.armor.item.max_dexmod: DEXmod = int(object.fighter.armor.item.max_dexmod)
    else: DEXmod = int((object.fighter.DEX-10)/2)
    AC = 10 + object.fighter.armor.item.ac + DEXmod + object.fighter.armor.item.enchanted
    return AC
def melee_dice_dmg(object, weapon):
    damage = dnd_dice(weapon.dmg[0], weapon.dmg[1]) + int((object.fighter.STR-10)/2 + weapon.dmg[2] + weapon.enchanted)
    return damage
def random_choice(chances_dict):
    chances = chances_dict.values()
    strings = chances_dict.keys()
    return strings[random_choice_index(chances)]
def random_choice_index(chances):
    dice = libtcod.random_get_int(0, 1, sum(chances))
    (running_sum, choice) = (0, 0)
    for w in chances:
        running_sum += w
        if dice <= running_sum: return choice
        choice += 1
def target_xy(focus=None):
    global game_state, xy_tile
    game_state = 'targeting'
    if focus == None: focus = player
    xy_tile = Object(focus.x, focus.y, 'X', 'targeting', libtcod.red)
    objects.append(xy_tile)
    while 1:
        render_all()
        key = libtcod.console_wait_for_keypress(True)    
        if key.vk in KP_MOVE:
            xy = (0,0)
            if key.vk == libtcod.KEY_KP9:   xy = (1, -1)
            elif key.vk == libtcod.KEY_KP8: xy = (0, -1)
            elif key.vk == libtcod.KEY_KP7: xy = (-1, -1)
            elif key.vk == libtcod.KEY_KP6: xy = (1, 0)
            elif key.vk == libtcod.KEY_KP4: xy = (-1, 0)
            elif key.vk == libtcod.KEY_KP3: xy = (1, 1)
            elif key.vk == libtcod.KEY_KP2: xy = (0, 1)
            elif key.vk == libtcod.KEY_KP1: xy = (-1, 1)
            if libtcod.map_is_in_fov(fov_map, xy_tile.x+xy[0],xy_tile.y+xy[1]):
                (xy_tile.x, xy_tile.y) = (xy_tile.x+xy[0], xy_tile.y+xy[1])
        elif key.vk == libtcod.KEY_KP5:
            (ttile_x, ttile_y) = (xy_tile.x, xy_tile.y)
            objects.remove(xy_tile)
            game_state = 'playing'
            return (ttile_x, ttile_y)
        elif key.vk == libtcod.KEY_ESCAPE:
            objects.remove(xy_tile)
            game_state = 'playing'
            return 'cancelled'
################################
#   GRAPHICS, MAIN AND DEF     #####################################################################################################
################################
libtcod.console_set_custom_font(FONT, libtcod.FONT_TYPE_GREYSCALE | libtcod.FONT_LAYOUT_TCOD)
libtcod.console_init_root(SCREEN_WIDTH, SCREEN_HEIGHT, 'Travel!', False)
con = libtcod.console_new(SCREEN_WIDTH, SCREEN_HEIGHT)
sidebar = libtcod.console_new(SIDEBAR_WIDTH, SIDEBAR_HEIGHT)
panel = libtcod.console_new(SCREEN_WIDTH, PANEL_HEIGHT)

def render_fov():
    global fov_recompute, fov_map
    fov_recompute = True
    libtcod.console_clear(con)
    fov_map = libtcod.map_new(MAP_WIDTH, MAP_HEIGHT)
    for y in range(MAP_HEIGHT):
        for x in range(MAP_WIDTH):
            libtcod.map_set_properties(fov_map, x, y, not map[x][y].block_sight, not map[x][y].blocked)
def render_sidebar():
    (pname_y, hp_y, mp_y, xp_y, dlevel_y, x, x2, x3) = (1, 50, 52, 54, 59, 5, 14, SIDEBAR_WIDTH/2)

    # Display raw text:
    libtcod.console_print_center(sidebar, SIDEBAR_WIDTH/2, pname_y-1, libtcod.BKGND_NONE, player.name.capitalize())
    otexts = [('Level:', pname_y+2, x), ('Race:', pname_y+3, x), ('Class:', pname_y+4, x),
              ('STR:', pname_y+6, x), ('DEX:', pname_y+7, x), ('CON:', pname_y+8, x), ('MAG:', pname_y+9, x),
              ('BAB:', pname_y+11, x), ('Attack:', pname_y+12, x), ('Damage:', pname_y+13, x), ('Defense:', pname_y+14, x),
              ('- Helm -', pname_y+16, x3), ('- Armor -', pname_y+18, x3), ('- RHand -', pname_y+21, x3), ('- LHand -', pname_y+23, x3)]
    wtexts = [(str(player.fighter.level), pname_y+2, x2), (player.race.capitalize(), pname_y+3, x2), (player.fighter.job.capitalize(), pname_y+4, x2),
              (' '+str(player.fighter.STR)+' ('+str((player.fighter.STR-10)/2)+')', pname_y+6, x2), 
              (' '+str(player.fighter.DEX)+' ('+str((player.fighter.DEX-10)/2)+')', pname_y+7, x2), 
              (' '+str(player.fighter.CON)+' ('+str((player.fighter.CON-10)/2)+')', pname_y+8, x2), 
              (' '+str(player.fighter.MAG)+' ('+str((player.fighter.MAG-10)/2)+')', pname_y+9, x2),
              (str(player.fighter.bab), pname_y+11, x2), (str(melee_dice_ab(player, player.fighter.rhand.item)), pname_y+12, x2),
              (str(player.fighter.rhand.item.dmg[0])+'-'+str(player.fighter.rhand.item.dmg[1])+
               '+'+str(int(player.fighter.rhand.item.dmg[2])+int(player.fighter.rhand.item.enchanted)+(int(player.fighter.STR-10)/2)), pname_y+13, x2),
              (str(melee_dice_ac(player)), pname_y+14, x2),
              (player.fighter.helm.name, pname_y+17, x3), (player.fighter.armor.name, pname_y+19, x3),
              (player.fighter.rhand.name, pname_y+22, x3), (player.fighter.lhand.name, pname_y+24, x3)]
    libtcod.console_set_foreground_color(sidebar, libtcod.orange)
    for text in otexts: libtcod.console_print_center(sidebar, text[2], text[1], libtcod.BKGND_NONE, text[0])
    libtcod.console_set_foreground_color(sidebar, libtcod.white)
    for text in wtexts: libtcod.console_print_center(sidebar, text[2], text[1], libtcod.BKGND_NONE, text[0])
    libtcod.console_print_center(sidebar, SIDEBAR_WIDTH/2, dlevel_y, libtcod.BKGND_NONE, dungeon_name+' level '+str(dungeon_level))    

    # Display bars with Health, Mana and XP:
    libtcod.console_set_foreground_color(sidebar, libtcod.white)
    bars = [('Health', hp_y, player.fighter.hp, player.fighter.max_hp, libtcod.darker_red, libtcod.red),
            ('Mana', mp_y, player.fighter.mp, player.fighter.max_mp, libtcod.darker_blue, libtcod.blue),
            ('XP', xp_y, player.fighter.xp, player.fighter.level*1000, libtcod.darker_violet, libtcod.violet)]
    for bar in bars:
        bar_width = int(float(bar[2]) / bar[3] * SIDEBAR_WIDTH)
        libtcod.console_print_center(sidebar, SIDEBAR_WIDTH/2, bar[1], libtcod.BKGND_NONE, bar[0]+': '+str(bar[2])+'/'+str(bar[3]))
        libtcod.console_set_background_color(sidebar, bar[4])
        libtcod.console_rect(sidebar, 0, bar[1], SIDEBAR_WIDTH, 1, False)
        libtcod.console_set_background_color(sidebar, bar[5])
        if bar_width != 0: libtcod.console_rect(sidebar, 0, bar[1], bar_width, 1, False)

    # Blit and clean up
    libtcod.console_set_background_color(sidebar, libtcod.black)
    libtcod.console_blit(sidebar, 0, 0, SIDEBAR_WIDTH, SIDEBAR_HEIGHT, 0, 0, 0)
    libtcod.console_clear(sidebar)
def render_panel(): # Need to clean this up
    global looting_target, looting_target_max

    libtcod.console_set_background_color(panel, libtcod.black)
    # Targeting part
    if game_state == 'targeting': target = xy_tile
    else: target = player
    objectlist = []; y = 1
    for obj in objects:
        if obj.x == target.x and obj.y == target.y and obj != target:
            objectlist.append(obj)
            if looting_target[1] == y-1:
                libtcod.console_set_foreground_color(panel, libtcod.orange)
                libtcod.console_print_center(panel, SIDEBAR_WIDTH/2, y, libtcod.BKGND_NONE, obj.name)
            else:
                libtcod.console_set_foreground_color(panel, libtcod.light_gray)
                libtcod.console_print_center(panel, SIDEBAR_WIDTH/2, y, libtcod.BKGND_NONE, obj.name)
            y += 1
    looting_target_max = len(objectlist)-1
    # Messages part
    y = 0
    for (line, color) in game_msgs:
        libtcod.console_set_foreground_color(panel, color)
        libtcod.console_print_left(panel, 20, y, libtcod.BKGND_NONE, line)
        y += 1

    PANEL_Y = SCREEN_HEIGHT - PANEL_HEIGHT
    libtcod.console_blit(panel, 0, 0, SCREEN_WIDTH, PANEL_HEIGHT, 0, 0, PANEL_Y)
    libtcod.console_clear(panel)
def render_all():
    global fov_map, fov_recompute
    # 1. FOV RECOMPUTE
    if fov_recompute: 
        fov_recompute = False
        libtcod.map_compute_fov(fov_map, player.x, player.y, TORCH_RADIUS, FOV_LIGHT_WALLS, FOV_ALGO)
    # 2. SET BG_COLOR DEPENDING ON FOV
    for y in range(MAP_HEIGHT):
        for x in range(MAP_WIDTH):
            visible = libtcod.map_is_in_fov(fov_map, x, y)
            wall = map[x][y].block_sight
            if not visible: # Not in FOV
                if map[x][y].explored or DEBUGMODE == 1:
                    if wall: libtcod.console_set_back(con, x, y, color_dark_wall, libtcod.BKGND_SET)
                    else: libtcod.console_set_back(con, x, y, color_dark_ground, libtcod.BKGND_SET)
            else: # In FOV
                    if wall: libtcod.console_set_back(con, x, y, color_light_wall, libtcod.BKGND_SET )
                    else: libtcod.console_set_back(con, x, y, color_light_ground, libtcod.BKGND_SET )                        
                    map[x][y].explored = True
    # DRAW ALL OBJECTS > CON
    for object in objects:
        if object.blocks == False: object.draw()
    for object in objects:
        if object.blocks == True:  object.draw()
    # BLIT CON > ROOT and render sidebar+panel
    libtcod.console_blit(con, 0, 0, SCREEN_WIDTH, SCREEN_HEIGHT, 0, SIDEBAR_WIDTH, 0)
    render_sidebar()
    render_panel()
    libtcod.console_flush()
    for object in objects:
            object.clear()

def message (new_msg, color = libtcod.white):
    (MSG_WIDTH, MSG_HEIGHT) = (60, PANEL_HEIGHT - 1)
    new_msg_lines = textwrap.wrap(new_msg, MSG_WIDTH)
    for line in new_msg_lines:
        # If buffer is full, remove the first line
        if len(game_msgs) == MSG_HEIGHT:
            del game_msgs[0]
        # Add new line
        game_msgs.append((line, color))
def inputbox(title, regex, width=50, height=3):
    inputstring = ''
    window = libtcod.console_new(width, height)
    libtcod.console_set_foreground_color(window, libtcod.white)
    while 1:
        libtcod.console_print_left_rect(window, 0, 0, width, height, libtcod.BKGND_NONE, title)
        libtcod.console_print_left(window, 0, 2, libtcod.BKGND_NONE, '> '+inputstring)
        libtcod.console_blit(window, 0, 0, width, height, 0, SCREEN_WIDTH/2 - width/2, SCREEN_HEIGHT/2 - height/2, 1.0, 1)
        libtcod.console_flush()
        libtcod.console_clear(window)
        key = libtcod.console_wait_for_keypress(True)
        key_char = chr(key.c)
        if key.vk == libtcod.KEY_BACKSPACE and inputstring != '':
            inputstring = inputstring[:len(inputstring)-1]
        elif key.vk == libtcod.KEY_ENTER: return inputstring
        elif key.vk == libtcod.KEY_ESCAPE: return ''
        else:
            key_char = re.search(regex,key_char)
            if key_char != None: inputstring = inputstring + str(key_char.group())
def msgbox(text, width=50, color=libtcod.white): # Small msgbox from menu command
    menu(text, [], width, textcolor=color)
def menu (header, options, width, sorting='1', transparency='0.7', textx=0, textcolor=libtcod.white, headercolor=libtcod.white):
    if len(options) > 26: raise ValueError('You cannot have a menu with more than 26 options')
    # Calculate total height for header after autowrap with 1 line per option
    header_height = libtcod.console_height_left_rect(con, 0, 0, width, SCREEN_HEIGHT, header)
    height = len(options) + header_height
    # Off console with options view
    window = libtcod.console_new(width, height)
    # Print header with autowrap
    libtcod.console_set_foreground_color(window, headercolor)
    libtcod.console_print_left_rect(window, 0, 0, width, height, libtcod.BKGND_NONE, header)
    # Print all the options
    libtcod.console_set_foreground_color(window, textcolor)
    y = header_height
    if header == '': header_height = 0
    letter_index = ord(sorting)
    for option_text in options:
        if option_text != "":
            if sorting != ' ': text = '(' + chr(letter_index) + ')' + option_text
            else: text = option_text
            libtcod.console_print_left(window, textx, y, libtcod.BKGND_NONE, text)
            y += 1
            letter_index += 1
    # Blit
    x = SCREEN_WIDTH/2 - width/2
    y = SCREEN_HEIGHT/2 - height/2
#    libtcod.console_blit(window, 0, 0, width, height, 0, x, y, 1.0, 0.7)
    libtcod.console_blit(window, 0, 0, width, height, 0, x, y, 1.0, float(transparency))
    # Wait for keypress
    libtcod.console_flush()
    key = libtcod.console_wait_for_keypress(True)
    if key.vk == libtcod.KEY_ENTER and key.lalt:  #(special case) Alt+Enter: toggle fullscreen
        libtcod.console_set_fullscreen(not libtcod.console_is_fullscreen())
    #convert the ASCII code to an index; if it corresponds to an option, return it
    index = key.c - ord(sorting)
    if index >= 0 and index < len(options): return index
    return None
################################
#     TRIGGERS AND ACTIONS     #####################################################################################################
################################
def check_level_up():
    if player.fighter.xp >= player.fighter.level*1000:
        player.fighter.xp -= player.fighter.level*1000
        player.fighter.level += 1
        message('You reached level ' + str(player.fighter.level) + '!', COLOR_BOON)
        player.fighter.hp_base += dnd_dice(1,8)
        player.fighter.mp_base += dnd_dice(1,6)
#        if player.fighter.level in (1,2,3,5,6,7,9,10,11,13,14,15,17,18,19,21,22,23,25,26,27,29,30,31,33,34,35,37,38,39):
        player.fighter.bab += 1
#        if player.fighter.level in (4, 8, 12, 16, 20, 24, 28, 32, 36, 40):
#        if player.fighter.level in (2, 4, 6, 8, 10, 12, 14, 16, 18, 20, 22, 24, 26, 28, 30, 32, 34, 36, 38, 40):
        choice = None
        while choice == None:
            choice = menu('Level up! Choose a stat to raise:\n',
                          ['+1 Strength, currently ' + str(player.fighter.STR),
                           '+1 Dexterity, currently ' + str(player.fighter.DEX),
                           '+1 Constitution, currently ' + str(player.fighter.CON),
                           '+1 Magic, currently ' + str(player.fighter.MAG)], LEVEL_SCREEN_WIDTH,'a')
        if   choice == 0: player.fighter.STR += 1
        elif choice == 1: player.fighter.DEX += 1
        elif choice == 2: player.fighter.CON += 1
        elif choice == 3: player.fighter.MAG += 1
        #ADD FEAT
#        if player.fighter.level in (3, 6, 9, 12, 15, 18, 21, 24, 27, 30, 33, 36, 39):
#            choice = None
#            while choice == None:
#                choice = menu('Level up! Choose a feat:\n',
#                              [,
#                               ,
#                               ,
#                               ], LEVEL_SCREEN_WIDTH,'a')
#                if choice == 0:
#                elif choice == 1:
#                elif choice == 2:
#                elif choice == 3:
    #Cleaning up. Setting all static info
        player.fighter.max_hp = player.fighter.hp_base + int(((player.fighter.CON -10)/2)*player.fighter.level)
        player.fighter.max_mp = player.fighter.mp_base + int(((player.fighter.MAG -10)/2)*player.fighter.level)

def loot_selected_target():
    y = 0
    for obj in objects:
        if obj.x == player.x and obj.y == player.y and obj != player and obj.lootable == 'yes':
            if looting_target[1] == y and looting_target[0] == True:
                chosen_item = obj.display_inventory(obj.name + '\n')
                if chosen_item != None:
                    chosen_item.pick_up(looted='yes')
                    obj.inventory.remove(chosen_item.owner)
            y += 1

def next_level():
    global dungeon_level
    
    if dungeon_name == 'Cave':
        message('You descend deeper...', libtcod.red)
        dungeon_level += 1
        make_map_cave()
        render_fov()
    else: message('You cannot go further down at the moment...')

def item_use(item):
    if item.consumable[0] == 0: message(item.owner.name.capitalize()+' is not useable')
    elif item.consumable[1] == 0: message(item.owner.name.capitalize()+' has no charges left')
    elif 'magic marker' in item.owner.name:
        string = inputbox('What do you want to engrave?\n','[a-zA-Z]+')
        if string != '':
            rune = Object(player.x, player.y, 'O', 'rune: '+string, COLOR_MAGIC, rune=True)
            objects.append(rune)
            message('You have engraved '+rune.name)
            return 'consume'
#    elif 'wand of digging' in item.owner.name:
        
def spell(spell):
    MANA_PRICE = 0
    if spell == 'blink':
        MANA_PRICE = 10
        message('You feel lighter', COLOR_MAGIC)
        (x, y) = target_xy()
        if not is_blocked(x, y):
            player.x = x
            player.y = y
            message('You blink', COLOR_MAGIC)
            fov_recompute = True

    if spell == 'magic_missile':
        MANA_PRICE = 10
        enemy = closest_enemy(15)
        if enemy == None: enemy = player
        message('You feel power at your fingertips', COLOR_MAGIC)
        (x, y) = target_xy()
        dmg = dnd_dice(1,4) + 1
        for no in range(int((player.fighter.MAG -10)/2)): dmg += dnd_dice(1,4) + 1 # 1 missile +1 per MAGmod
        for object in objects:
            if object.x == x and object.y == y and object.fighter and object != player:
                message('Magic missiles hit ' + object.name + ' for ' + str(dmg) + ' damage.', COLOR_MAGIC)
                object.fighter.take_damage(dmg)
        message('The power fades', COLOR_MAGIC)

    if player.fighter.mp >= MANA_PRICE: player.fighter.mp -= MANA_PRICE
    else:
        hp_damage = MANA_PRICE - player.fighter.mp
        player.fighter.mp = 0
        message ('Your feel a sudden pain in your head!', libtcod.red)
        player.fighter.take_damage(hp_damage)

def remove_item():
    choice = menu('Which item do you want to remove?\n',
                  ['Helm: ' + player.fighter.helm.name + '\n',
                   'Armor: ' + player.fighter.armor.name + '\n',
                   'R Hand: ' + player.fighter.rhand.name + '\n',
                   'L Hand: ' + player.fighter.lhand.name + '\n'], LEVEL_SCREEN_WIDTH)
    if choice == 0:
        if player.fighter.helm.name == '':
            message('You have no helmet to remove')
        else:
            message('Removed ' + player.fighter.helm.name)
            player.inventory.append(player.fighter.helm)
            player.fighter.helm = AC_empty
    elif choice == 1:
        if player.fighter.armor.name == '':
            message('You have no armor to remove')
        else:
            message('Removed ' + player.fighter.armor.name)
            player.inventory.append(player.fighter.armor)
            player.fighter.armor = AC_empty
    elif choice == 2:
        if player.fighter.rhand.name == '':
            message('Your right hand is empty')
        else:
            message('Removed ' + player.fighter.rhand.name + ' from right hand')
            player.inventory.append(player.fighter.rhand)
            player.fighter.rhand = AC_empty
    elif choice == 3:
        if player.fighter.lhand.name == '':
            message('Your left hand is empty')
        else:
            message('Removed ' + player.fighter.lhand.name + ' from left hand')
            player.inventory.append(player.fighter.lhand)
            player.fighter.lhand = AC_empty

# Inventory
def inventory_menu(header, mode):
    if len(player.inventory) == 0:
        message('Your inventory is empty')
    else:
        if mode == 'u': # Use
            options = [item.name for item in player.inventory]
            if len(options) > 0: 
                index = menu(header, options, INVENTORY_WIDTH, 'a', '1')
                if index != None: return player.inventory[index].item
        if mode == 'w': # Wield
            options = [item.name for item in player.inventory if item.item.equippable == 'hand']
            if len(options) > 0: index = menu(header, options, INVENTORY_WIDTH, 'a', '1')
            else: 
                message('You have no weapon to equip')
                index = None
            if index != None:
                optlist = [item for item in player.inventory if item.item.equippable == 'hand']
                chosen_item = optlist[index].item
                hand = menu('In which hand do you want to equip it?\n',
                            ['Right hand\n','Left hand'], INVENTORY_WIDTH,'a', '1')
                if hand == 0:   w_hand='right'
                elif hand == 1: w_hand='left'
                if hand != None: chosen_item.equip(w_hand)
        elif mode == 'W': # Wear
            options = [item.name for item in player.inventory if item.item.equippable == 'armor']
            if len(options) > 0: index = menu(header, options, INVENTORY_WIDTH, 'a', '1')
            else: 
                message('You have no armor to wear')
                index = None
            if index != None:
                optlist = [item for item in player.inventory if item.item.equippable == 'armor']
                chosen_item = optlist[index].item
                chosen_item.equip()


def player_speak():
    speakstring = inputbox('What do you want to say?','[a-z ]+')
    if speakstring != "": 
        message(player.name.capitalize()+' says: '+speakstring) # Player speaks
        #http://www.arwen-undomiel.com/elvish/eng_to_elv.html
        #Earth,Water,Fire,Wind,Light,Darkness,Dust,Fate ,Empty
        #kemen,nen  ,nar ,sul ,galad,fuin    ,ast ,ambar,lost
        #http://www.irishdictionary.ie/dictionary
        #talamh, uisce, tine, gaoth, solas, dorchadas, deannach, cinniuint, folamh

        if speakstring == 'kemen ast sul': spell('blink')
        elif speakstring == 'sul nar nen galad': spell('magic_missile')
def rune_take_turn():
    runelist = []
    for object in objects:
        if object.rune:
            runelist.append((object.x, object.y))
    for object in objects:
        if object.fighter:
            if (object.x, object.y) in runelist:
                if libtcod.map_is_in_fov(fov_map, object.x, object.y): message('The magic runes burns '+object.name+'!', COLOR_ALARM)
                object.fighter.take_damage(dnd_dice(1,8))

def spawn_item(name, enchanted=0):
    #""" ARMOR """
    # Light
    if name == 'AC_a_cloak': returned_item = Object(0, 0, '(', 'cloak', libtcod.darker_green, item=Item(
            itemtype='armor', weight='light', equippable='armor', ac=2, max_dexmod=100))
    # Medium
    elif name == 'AC_a_leather_armor': returned_item = Object(0, 0, '[', 'leather armor', libtcod.darker_orange, item=Item(
            itemtype='armor', weight='medium', equippable='armor', ac=4, max_dexmod=8))
    # Heavy
    elif name == 'AC_a_chainmail': returned_item = Object(0, 0, '[', 'chainmail', libtcod.dark_grey, item=Item(
            itemtype='armor', weight='medium', equippable='armor', ac=6, max_dexmod=4))

    #""" MAGIC ITEMS / TOOLS """
    elif name == 'AC_i_magicmarker': returned_item = Object(0, 0, 'i', 'magic marker', libtcod.cyan, item=Item(
            itemtype='tool', weight='light', use_function='yes', consumable=(1,5)))
    elif name == 'AC_w_digging': returned_item = Object(0, 0, '/', 'wand of digging', libtcod.cyan, item=Item(
            itemtype='tool', weight='light', use_function='yes', consumable=(1,dnd_dice(1,5))))

    #""" WEAPONS """
    # Light
    elif name == 'AC_w_dagger': returned_item = Object(0, 0, ')', 'dagger', libtcod.dark_grey, item=Item(
            itemtype='sword', weight='light', equippable='hand', dmg=(1,4,0)))
    # Medium
    elif name == 'AC_w_shortsword': returned_item = Object(0, 0, ')', 'shortsword', libtcod.dark_grey, item=Item(
            itemtype='sword', weight='medium', equippable='hand', dmg=(1,6,0)))
    # Heavy
    elif name == 'AC_w_longsword': returned_item = Object(0, 0, ')', 'longsword', libtcod.dark_grey, item=Item(
            itemtype='sword', weight='heavy', equippable='hand', dmg=(1,8,0)))
    elif name == 'AC_w_greatsword': returned_item = Object(0, 0, ')', 'greatsword', libtcod.dark_grey, item=Item(
            itemtype='sword', weight='heavy', equippable='hands', dmg=(1,11,1)))

    #""" ENCHANTMENT HERE """
    if enchanted > 0: 
        returned_item.item.enchanted = enchanted
        returned_item.name = returned_item.name+' +'+str(returned_item.item.enchanted)

    return returned_item
def new_player(player_name):
    global player

    player_component = Fighter(hp=20, STR=10, DEX=10, CON=10, MAG=10, xp=0, mp=0, job='rogue', faction='player', level=1, bab=1, death_function=player_death)
    player = Object(0, 0, '@', player_name, libtcod.white, race='human', blocks=True, inventory=[], spellbook=[], fighter=player_component)
    if player.fighter.job == 'rogue':
        player.fighter.hp_base = 8
        player.fighter.mp_base = 6
        player.fighter.armor = spawn_item('AC_a_leather_armor')
        player.fighter.rhand = spawn_item('AC_w_shortsword')
        player.inventory.append(spawn_item('AC_i_magicmarker'))
    #Add the CONmod to HP && MAGmod to MP
    player.fighter.hp = player.fighter.hp_base + int((player.fighter.CON -10)/2)
    player.fighter.mp = player.fighter.mp_base + int((player.fighter.MAG -10)/2)
    player.fighter.max_hp = player.fighter.hp
    player.fighter.max_mp = player.fighter.mp
def from_dungeon_level(table):
    #returns a value that depends on level. the table specifies what value occurs after each level, default is 0.
    for (value, level) in reversed(table):
        if dungeon_level >= level:
            return value
    return 0
def place_objects(room):
 
    # Item and monster chance
    if dungeon_name == 'Cave':
        monster_chances = {}
        monster_chances['goblin'] = 80  #goblin always shows up, even if all other monsters have 0 chance
        monster_chances['goblinelite'] = from_dungeon_level([[2, 1],[5, 2],[10, 3],[15,4],[20, 5]])
        max_monsters_per_room = from_dungeon_level([[2, 1], [3, 3], [4, 5]])

    # Place stuff
    for i in range(dnd_dice(0,max_monsters_per_room)):
        x = libtcod.random_get_int(0, room.x1+1, room.x2-1)
        y = libtcod.random_get_int(0, room.y1+1, room.y2-1)
        if not is_blocked(x, y):
            choice = random_choice(monster_chances)
            monster_append(choice, x, y)
#    for i in rance(dnd_dice(0,max_items)):
#        x = libtcod.random_get_int(0, room.x1+1, room.x2-1)
#        y = libtcod.random_get_int(0, room.y1+1, room.y2-1)
#        if not is_blocked(x, y):
#            choice = random_choice(item_chances)
#            item_append(choice, x, y)
#
#def item_append(item_id, x, y):
    

def monster_append(monster_id, x, y): #Append monster to objects
    monster_inventory = []
    #monster_vs_player
    #chaotic
    #monster vs monsters
    mvp = BasicMonster()
    (w_enchanted, a_enchanted) = (dnd_dice(1, 10), dnd_dice(1, 10))
    if w_enchanted > 1: w_enchanted = 0
    if a_enchanted > 1: a_enchanted = 0

    if dungeon_name == 'Cave':
        if monster_id == 'goblin':
            fighter_component = Fighter(hp=4, STR=10, DEX=10, CON=6, MAG=0, xp=35,level=1, death_function=monster_death)
            monster = Object(x, y, 'g', 'goblin', libtcod.yellow, blocks=True, inventory=monster_inventory, fighter=fighter_component, ai=mvp)
            if dnd_dice(1,2) == 1: monster.fighter.rhand = spawn_item('AC_w_shortsword')
            else: monster.fighter.rhand = spawn_item('AC_w_dagger')
        elif monster_id == 'goblinelite':
            fighter_component = Fighter(hp=17, STR=12, DEX=12, CON=8, MAG=0, xp=100, level=3, death_function=monster_death)
            monster = Object(x, y, 'g', 'goblin elite', libtcod.orange, blocks=True, inventory=monster_inventory, fighter=fighter_component, ai=mvp)
            # Weapon
            if dnd_dice(1,2) == 1: monster.fighter.rhand = spawn_item('AC_w_shortsword', w_enchanted)
            else: monster.fighter.rhand = spawn_item('AC_w_dagger', w_enchanted)
            # Armor
            if dnd_dice(1,2) == 1: monster.fighter.armor = spawn_item('AC_a_chainmail', a_enchanted)
            else: monster.fighter.armor = spawn_item('AC_a_leather_armor', a_enchanted)

    if DEBUGMODE == 1:
        print('Spawned '+monster.name+' ('+monster.fighter.rhand.name+','+monster.fighter.armor.name+')')
    objects.append(monster)
#################################### 
######### Creating the map #########
#################################### 
##### Cave map
def make_map_cave():
    global map, objects, stairsdown#, portal
    if DEBUGMODE == 1:print('Creating '+dungeon_name+' level '+str(dungeon_level))

    ROOM_SIZE = (6, 10)
    MAX_ROOMS = 50

    objects = [player]
    rooms = []; num_rooms = 0

    # Fill map with blocked tiles..
    map = [[ Tile(True)
        for y in range(MAP_HEIGHT) ]
           for x in range(MAP_WIDTH) ]

    # Fill map with rooms
    for r in range(MAX_ROOMS):
        w = libtcod.random_get_int(0, ROOM_SIZE[0], ROOM_SIZE[1])
        h = libtcod.random_get_int(0, ROOM_SIZE[0], ROOM_SIZE[1])
        x = libtcod.random_get_int(0, 0, MAP_WIDTH - w - 1)
        y = libtcod.random_get_int(0, 0, MAP_HEIGHT - h - 2)
        new_room = Rect(x, y, w, h)
         #run through the other rooms and see if they intersect with this one
        failed = False
        for other_room in rooms:
            if new_room.intersect(other_room):
                failed = True
                break
        if not failed:
            create_room(new_room)
            (new_x, new_y) = new_room.center() #center coordinates of new room, will be useful later
            if num_rooms == 0: #this is the first room, where the player starts at
                player.x = new_x
                player.y = new_y
            else: #all rooms after the first:
                place_objects(new_room)
                #connect it to the previous room with a tunnel
                (prev_x, prev_y) = rooms[num_rooms-1].center()
                if libtcod.random_get_int(0, 0, 1) == 1: #First move horizontally, then vertically
                    create_h_tunnel(prev_x, new_x, prev_y)
                    create_v_tunnel(prev_y, new_y, new_x)
                else: #first move vertically, then horizontally
                    create_v_tunnel(prev_y, new_y, prev_x)
                    create_h_tunnel(prev_x, new_x, new_y)
            rooms.append(new_room)
            num_rooms += 1

    stairsdown = Object(new_x, new_y, '>', 'stairs going down', libtcod.white, always_visible=True)
    objects.append(stairsdown)
    if DEBUGMODE == 1:print('make_map_cave - OK')

##### Village
def make_map_village():
    global map, objects, stairsdown

    player.x = MAP_WIDTH/2
    player.y = MAP_HEIGHT/2

#    create_v_tunnel(y1,y2,x)
#    create_v_tunnel(1,MAP_HEIGHT-2,1)
#    create_v_tunnel(1,MAP_HEIGHT-2,MAP_WIDTH-2)
#    create_h_tunnel(1,MAP_WIDTH-2,1)
#    create_h_tunnel(1,MAP_WIDTH-2,MAP_HEIGHT-2)

    ROOM_SIZE = (6, 10)
    MAX_ROOMS = 30

    objects = [player]

    # Fill map with blocked tiles..
    map = [[ Tile(True)
        for y in range(MAP_HEIGHT) ]
           for x in range(MAP_WIDTH) ]

    create_room(Rect((MAP_WIDTH/2)-10, (MAP_HEIGHT/2)-10, 20, 20))
####################################
# All ai take turn
def ai_take_turn():
    for object in objects:
        if object.ai:
            object.ai.take_turn()
################################
# Movement functions
def player_move_or_attack(dx, dy):
    global fov_recompute
    x = player.x + dx; y = player.y + dy #Check what is there and grep it
    target = None

    for object in objects:
        if object.fighter and object.x == x and object.y == y:
            target = object
            break
    if target != None and target != player: player.fighter.attack(target)
    else:
        player.move(dx, dy)
        fov_recompute = True

######### Key-pressing commands #########
def handle_keys():
    global fov_recompute, game_state

    if game_state == 'waiting': key = libtcod.console_check_for_keypress(libtcod.KEY_PRESSED) # Real-time
    else: key = libtcod.console_wait_for_keypress(True) # Turn-based
    key_char = chr(key.c)

    """ SPECIAL CHECK FOR LOOTING """
    if key.vk != libtcod.KEY_KPADD and key.vk != libtcod.KEY_KPSUB and key_char != 'l': looting_target[1] = 0

    """ GENERAL COMMANDS (DESPITE PLAYING / DEAD) """
    if key.vk == libtcod.KEY_ENTER and key.lalt: libtcod.console_set_fullscreen (not libtcod.console_is_fullscreen())
    elif key.vk == libtcod.KEY_ESCAPE: return 'exit'

    if game_state == 'playing':

        if key.vk == libtcod.KEY_KPADD:
            looting_target[1] += 1
            if looting_target[1] > looting_target_max: looting_target[1] = looting_target_max
            return 'didnt_take_turn'
        elif key.vk == libtcod.KEY_KPSUB:
            looting_target[1] -=1
            if looting_target[1] < 0: looting_target[1] = 0
            return 'didnt_take_turn'
                
        """KP_KEYS = MOVEMENT """
        if key.vk == libtcod.KEY_KP9:   player_move_or_attack(1, -1)
        elif key.vk == libtcod.KEY_KP8: player_move_or_attack(0, -1)
        elif key.vk == libtcod.KEY_KP7: player_move_or_attack(-1, -1)
        elif key.vk == libtcod.KEY_KP6: player_move_or_attack(1, 0)
        elif key.vk == libtcod.KEY_KP5: player_move_or_attack(0, 0)
        elif key.vk == libtcod.KEY_KP4: player_move_or_attack(-1, 0)
        elif key.vk == libtcod.KEY_KP3: player_move_or_attack(1, 1)
        elif key.vk == libtcod.KEY_KP2: player_move_or_attack(0, 1)
        elif key.vk == libtcod.KEY_KP1: player_move_or_attack(-1, 1)

        elif key.vk == libtcod.KEY_KP0: # Pick up item
            for object in objects:
                if object.x == player.x and object.y == player.y and object.item:
                    object.item.pick_up()
                    break
                
                """ A-Z """
#elif key_char == 'a':
#elif key_char == 'b':
#elif key_char == 'c': 
#elif key_char == 'd': #[FIX]
#chosen_item = inventory_menu('Press the key next to an item to drop it, or any other to cancel.\n')
#if chosen_item is not None:
#chosen_item.drop()
#elif key_char == 'e':
#elif key_char == 'f':
#elif key_char == 'g':
#elif key_char == 'h':
#elif key_char == 'i':
#elif key_char == 'j':
#elif key_char == 'k':
        elif key_char == 'l': #show inventory of monster at current location
            looting_target[0] = True
            loot_selected_target()
            looting_target[0] = False
#elif key_char == 'm':
        elif key_char == 'M' and DEBUGMODE == 1:
            cheat = menu('Cheat Menu\n',
                        ['Crash game\n','Level up\n', 'Next Level\n', 'Full HP/MANA'], INVENTORY_WIDTH,'1', '1')
            if cheat == 0:   crash_game()
            elif cheat == 1: player.fighter.xp = player.fighter.level*1000
            elif cheat == 2: next_level()
            elif cheat == 3: 
                player.fighter.hp = player.fighter.max_hp
                player.fighter.mp = player.fighter.max_mp

#elif key_char == 'n':
#elif key_char == 'o':
#elif key_char == 'p':
#elif key_char == 'q'
        elif key_char == 'r': remove_item()
#elif key_char == 's':
        elif key_char == 'S': player_speak()
#elif key_char == 't':
        elif key_char == 'u':
            chosen_item = inventory_menu('Which item do you want to use?\n', 'u')
            if chosen_item is not None:
                chosen_item.use()
#elif key_char == 'v':
        elif key_char == 'w': chosen_item = inventory_menu('What do you want to wield?\n', 'w')
        elif key_char == 'W': chosen_item = inventory_menu('What do you want to wear?\n', 'W')
        elif key_char == 'x': 
            target_xy()
            return 'didnt_take_turn'
#elif key_char == 'y':
#elif key_char == 'z':
#elif key_char == 'Z': # Magic
#chosen_magic = magic_menu('What magic to use?\n')
#if chosen_magic is not None: chosen_magic.use()

            #""" SPECIAL CHARACTERS """
        elif key.vk == libtcod.KEY_SPACE:
            if player.fighter.hp != player.fighter.max_hp or player.fighter.mp != player.fighter.max_mp:
                game_state = 'waiting'
                message('Resting..')
        elif key_char == '>':
            if stairsdown.x == player.x and stairsdown.y == player.y: next_level()
        elif key_char == ',':
            for object in objects:
                if object.x == player.x and object.y == player.y and object.item:
                    object.item.pick_up()
                    break

#elif key_char == '?':
            
            
        else: return 'didnt_take_turn'

#########################################
######### Death functions #########
def player_death(player):
    global game_state
    message('You have died!', libtcod.red)
    game_state = 'dead'
    player.char = '%'
    player.color = libtcod.dark_red
    player.dlevel = dungeon_level
    try:
        file = shelve.open('save/.graveyard', 'w')
        characters = file['characters']
        characters.append(player)
        file['characters'] = characters
        file.close()    
    except:
        file = shelve.open('save/.graveyard', 'n')
        characters = [player]
        file['characters'] = characters
        file.close()    
    
def monster_death(monster):
    message(monster.name.capitalize() + ' was slain', COLOR_WARNING)
    monster.char = '%'
    monster.color = libtcod.dark_red
    monster.blocks = False
    monster.lootable = 'yes'
    monster.ai = None
    monster.name = monster.name + ' corpse'
    #Drop all held items and put into inventory
    if monster.fighter.helm.name != '':  monster.inventory.append(monster.fighter.helm)
    if monster.fighter.armor.name != '': monster.inventory.append(monster.fighter.armor)
    if monster.fighter.rhand.name != '': monster.inventory.append(monster.fighter.rhand)
    if monster.fighter.lhand.name != '': monster.inventory.append(monster.fighter.lhand)
    monster.fighter = None
################################
#     MAIN GAME MODES HERE     #####################################################################################################
################################
# Set modes here 
def main_menu():
    global main_menu_bg
    main_menu_bg = libtcod.image_load('Gloomy_Mountain.png')
    debug() #Special stuff if arguments are added
    while not libtcod.console_is_window_closed():
        libtcod.image_blit_2x(main_menu_bg, 0, 0, 0)
        libtcod.console_set_foreground_color(0, libtcod.white)
        printlist = [('Travel!',SCREEN_HEIGHT/2-4),
                     ('(L)oad Game', SCREEN_HEIGHT/2),
                     ('(N)ew game', SCREEN_HEIGHT/2+2),
                     ('(Q)uit', SCREEN_HEIGHT/2+4),
                     ('(G)raveyard', SCREEN_HEIGHT/2+12),
                     ('A python roguelike', SCREEN_HEIGHT-2),
                     ('Created by Olle Kvarnstr;m', SCREEN_HEIGHT-1)]
        for (text, y) in printlist: libtcod.console_print_center(0, SCREEN_WIDTH/2, y, libtcod.BKGND_NONE, text)
        libtcod.console_flush()
        key_char = chr(libtcod.console_wait_for_keypress(True).c)
        if key_char == 'l': # Load game
            loadgame_ok = load_game()
            if loadgame_ok: play_game()
        elif key_char == 'n': # Start new game
            newgame_ok = new_game()
            if newgame_ok: play_game()
        elif key_char == 'q': # Quit
            break
        elif key_char == 'g':
            try: graveyard()
            except: msgbox('\n The graveyard is empty\n', 27)
def graveyard():
    file = shelve.open('save/.graveyard')
    characters = file['characters']
    file.close()
    char_list = []
    for char in characters:
        char_list.append((char.name, char.fighter.level, char.dlevel, char.fighter.job))
    char_list = sorted(char_list, key=lambda char: (char[2], char[1]), reverse=True)
    objects = ['No Name                 CLvl DLvl Class\n']
    no = 1
    for char in char_list:
        if no <= 25: 
            num = str(no)
            if len(num) == 1: num = ' '+str(no)
            space = '                       '
            space1 = space[:(len(space)-len(char[0]))]
            objects.append(num+' '+str(char[0])+space1+str(char[1])+'    '+str(char[2])+'  '+str(char[3]))
            no += 1
        else: break
    index = menu('               Graveyard\n', objects, 40, ' ', 1)
def save_game():
    #open a new empty shelve (possibly overwriting an old one) to write the game data
    if game_state == 'dead':
        if os.path.isfile('save/'+player.name): os.remove('save/'+player.name)
    else:
        file = shelve.open('save/'+player.name, 'n')
        file['map'] = map
        file['objects'] = objects
        file['player_index'] = objects.index(player)  #index of player in objects list
        file['game_msgs'] = game_msgs
        file['game_state'] = game_state
        file['dungeon_level'] = dungeon_level
        file['dungeon_name'] = dungeon_name
        file['stairs_index'] = objects.index(stairsdown)
        file.close()
def load_game():
    #open the previously saved shelve and load the game data
    global map, objects, player, game_msgs, game_state, stairsdown, dungeon_level, dungeon_name
    options = [game for game in os.listdir('save/') if game != '.graveyard']
    if len(options) == 0: msgbox('\n No savegames exist\n', 27)
    else: 
        index = menu('Select savegame\n', options, INVENTORY_WIDTH, 'a')
        if index == None: return
        else:
            savegame = options[index]
            # Shelve'it!
            file = shelve.open('save/'+str(savegame), 'r')
            map = file['map']
            objects = file['objects']
            player = objects[file['player_index']]
            game_msgs = file['game_msgs']
            game_state = file['game_state']
            dungeon_level = file['dungeon_level']
            dungeon_name = file['dungeon_name']
            stairsdown = objects[file['stairs_index']]
            file.close()
            render_fov()
            return True
def new_game(testing=False):
    global game_msgs, game_state, dungeon_level, dungeon_name
    if testing: player_name = 'test'
    else: player_name = inputbox('Player name?','[a-zA-Z]+').capitalize()
    if player_name != '':
        new_player(player_name)
        dungeon_name = 'Cave'
        dungeon_level = 1
        make_map_cave()
        render_fov()
        game_state = 'playing'
        game_msgs = []
        return True
def play_game():
    global recover, game_state
    player_action = None
    while not libtcod.console_is_window_closed():

        if (game_state == 'playing' and player_action != 'didnt_take_turn') or game_state == 'waiting': 
            ai_take_turn()
            rune_take_turn()
        render_all()
        check_level_up()
        
        player_action = handle_keys()
        if player_action == 'exit':
            if game_state == 'waiting': game_state = 'playing'
            save_game()
            break

        # Waiting is done here
        if game_state == 'waiting':
            for object in objects:
                if object.ai and object != player and libtcod.map_is_in_fov(fov_map, object.x, object.y):
                    message(object.name.capitalize() + ' in sight!')
                    game_state = 'playing'
            if player.fighter.hp == player.fighter.max_hp and player.fighter.mp == player.fighter.max_mp:
                game_state = 'playing'

       # Heal mana & HP
        recover += 1
        if recover >= 20:
            recover = 0
            player.fighter.heal(1)
            player.fighter.heal_mp(1)



# List of Defines
AC_empty = Object(0, 0, '', '', libtcod.dark_grey, item=Item(itemtype='all', weight='none', equippable='all', dmg = (1,2,0), ac=0, max_dexmod=100))
KP_MOVE = [libtcod.KEY_KP1, libtcod.KEY_KP2, libtcod.KEY_KP3, libtcod.KEY_KP4, 
           libtcod.KEY_KP6, libtcod.KEY_KP7, libtcod.KEY_KP8, libtcod.KEY_KP9]
looting_target_max = 0
looting_target = [False, 0]
recover = 0
DEBUGMODE = 0;print('DEBUGMODE set to '+str(DEBUGMODE))

main_menu()

##############################
#         WHAT TO DO         #####################################################################################################
##############################
"""
PRIO HIGH:
   Make 'wield' weapon ask if you want to replace old one
   Two-weapon fighting
   More weapons (esp. heavy)
   Fix the messy graphic def
   Make a nicer menu, esp for inventory

PRIO MED:
   Re-add fighter
   Re-add mage
   Add potions/random items to level
   Add random starting items
   Re-add drop-function
   Add 's'neak
   Add some way to give +STR/DEX/CON/MAG
   Make the loot-meny being used for targeting monsters and picking up items

PRIO LOW:
   Make it possible to walk long
   Make a '?'
   Add some way to document and learn spells
   Re-add throw function
   Add items to monsters
   Add monster shout (make people nearby notice player)
"""
# ADDED THIS VERSION:
"""
"""
